<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="author" content="https://www.twitch.tv/quantum075">
  <title>Twitch Orb Overlay</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      height: 100%;
    }

    .orb {
      position: absolute;
      width: 15px;
      height: 15px;
      background: white;
      border-radius: 50%;
      filter: blur(5px);
      opacity: 0;
      transition: opacity 3s ease;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <script>
    // Количество циклов появления орба в период его активности
    const maxIterations = 5;
    // Время респауна/неактивности орба
    const spawnInterval = 60 * 1000;
    // Время видимости орба во время одного цикла
    const movementDuration = 10 * 1000;
    // Время плавного исчезновения (должно быть равно transition в CSS)
    const fadeDuration = 3 * 1000;
    // Время, в течении которого орб не видно в пробежутках между циклами видимости в активном состоянии
    const pauseDuration = 5000;
    // Максимальная и минимальная начальная скорость орба
    const minStartSpeed = 25;
    const maxStartSpeed = 35;
    // Максимальная и минимальная скорость орба
    const minSpeed = 10;
    const maxSpeed = 50;
    // Сила притяжения к центру
    const pullStrength = 0.005;
    // Вытягиваем параметры из урла
    const urlParams = new URLSearchParams(window.location.search);
    const whSecret = urlParams.get('secret');
    const whId = urlParams.get('id');

    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    function createOrb() {
      console.log("[D]: createOrb");
      const orb = document.createElement('div');
      orb.className = 'orb';
      orb.style.opacity = '0';
      document.body.appendChild(orb);

      // Плавное появление после следующего кадра
      requestAnimationFrame(() => {
        orb.style.opacity = '1';
      });

      return orb;
    }

    function animateOrb(orb, onComplete) {
      console.log("[D]: animateOrb");
      const { innerWidth: width, innerHeight: height } = window;
      const centerX = width / 2;
      const centerY = height / 2;

      let x = random(0, width);
      let y = random(0, height);

      orb.style.left = `${x}px`;
      orb.style.top = `${y}px`;

      let startTime = null;
      let direction = random(0, 2 * Math.PI);
      let speed = random(minStartSpeed, maxStartSpeed);
      let fadingOut = false;

      function update(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;

        // Исчезновение в рамках одного цикла
        if (window.orbIsCatched || (elapsed > movementDuration && !fadingOut)) {
          fadingOut = true;
          orb.style.opacity = 0;
          setTimeout(() => {
            orb.remove();
            onComplete();
          }, fadeDuration);
          return; // Stop animation loop
        }

        // Притяжение к центру
        const toCenterX = centerX - x;
        const toCenterY = centerY - y;
        const angleToCenter = Math.atan2(toCenterY, toCenterX);
        direction += pullStrength * Math.sin(angleToCenter - direction);

        // Случайные отклонения
        direction += random(-0.05, 0.05);
        speed += random(-2, 2);
        speed = Math.max(minSpeed, Math.min(speed, maxSpeed));

        x += Math.cos(direction) * speed * 0.016;
        y += Math.sin(direction) * speed * 0.016;

        orb.style.left = `${x}px`;
        orb.style.top = `${y}px`;

        requestAnimationFrame(update);
      }

      requestAnimationFrame(update);
    }

    function startOrbCycle() {
      console.log("[D]: startOrbCycle");
      if (window.isOrbCycleRunning) return; // Предотвращаем множественные запуски
      window.isOrbCycleRunning = true;
      window.isOrbActive = true;
      let iteration = 0;

      function spawnNext() {
        console.log("[D]: spawnNext");
        if (iteration >= maxIterations || window.orbIsCatched) {
          window.isOrbActive = false;
          window.isOrbCycleRunning = false;
          if (window.orbIsCatched) {
            console.log("Орб пойман! Следующий появится через 60 секунд.");
            window.orbIsCatched = false;
          }
          // Schedule next cycle only if not already scheduled
          if (!window.orbSpawnTimeout) {
            window.orbSpawnTimeout = setTimeout(() => {
              window.orbSpawnTimeout = null;
              startOrbCycle();
            }, spawnInterval);
          }
          return;
        }

        const orb = createOrb();
        animateOrb(orb, () => {
          setTimeout(() => {
            iteration++;
            spawnNext();
          }, pauseDuration);
        });
      }

      spawnNext();
    }

    // Initialize first cycle
    window.orbSpawnTimeout = setTimeout(() => {
      window.orbSpawnTimeout = null;
      startOrbCycle();
    }, 1000);

    function callWebhookCatched(user) {
      var xhr = new XMLHttpRequest();
      xhr.open("POST", "https://api.mixitupapp.com/api/webhook/" + whId + "?secret=" + whSecret, true);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify({
          user: user
      }));
    }

    function cmdOrbHandler(nick) {
      if (!window.isOrbActive) {
        console.log("Орб не активен, игнорируем команду.");
        return;
      }
      console.log("Пользователь @" + nick + " обнаружил орб! Молодец!");
      callWebhookCatched(nick);
      window.orbIsCatched = true;
      // Clear any existing spawn timeout to ensure 60-second delay
      if (window.orbSpawnTimeout) {
        clearTimeout(window.orbSpawnTimeout);
        window.orbSpawnTimeout = null;
      }
    }

    function cmdSpawnHandler() {
      console.log("[D]: cmdSpawnHandler");
      if (!window.isOrbCycleRunning && !window.orbSpawnTimeout) {
        // Start a new cycle immediately
        startOrbCycle();
        console.log("Цикл орба принудительно запущен.");
      } else {
        console.log("Цикл уже активен или запланирован, игнорируем команду.");
      }
    }

    window.addEventListener('onEventReceived', function (obj) {
      console.log("[D]: onEventReceived");
      if (!obj.detail.event) {
        return;
      }
      const listener = obj.detail.listener;
      const data = obj.detail.event.data;

      if (listener === 'message') {
        if (data.text === "!orb" || data.text === "!орб") {
          cmdOrbHandler(data.nick);
        }

        if (data.text === "!чопоорбам") {
          cmdSpawnHandler();
        }
      }
    });

    window.orbIsCatched = false;
    window.isOrbActive = false;
    window.isOrbCycleRunning = false;
    window.orbSpawnTimeout = null;
  </script>
</body>
</html>
